package exploit

import (
	"encoding/base64"
	"fmt"
	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/panjf2000/ants"
	"io"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"
	poc_check "vulAssess/depot/pocV/common/check"
	nuclei_parse "vulAssess/depot/pocV/pkg/nuclei/parse"
	nuclei_structs "vulAssess/depot/pocV/pkg/nuclei/structs"
	xray_parse "vulAssess/depot/pocV/pkg/xray/parse"
	xray_struct "vulAssess/depot/pocV/pkg/xray/structs"
)

type Task struct {
	Client  *Client
	Service string
	Version string
	POC     POC
}

type PocResult struct {
	Success bool
	Service string
	Version string
	PocName string `json:"poc_name"`
}

type Result struct {
	Client *Client
	PocRes *PocResult
}

var (
	Ticker *time.Ticker
	Pool   *ants.PoolWithFunc

	WaitGroup     sync.WaitGroup
	done          = make(chan struct{})
	OutputChannel chan *Result
)

// InitCheck 初始化协程池
func InitCheck(threads, rate int) error {
	var err error
	rateLimit := time.Second / time.Duration(rate)
	Ticker = time.NewTicker(rateLimit)
	Pool, err = ants.NewPoolWithFunc(threads, check)
	if err != nil {
		return err
	}
	return nil
}

// Start 初始分配任务
func Start(outputChannel chan *Result) error {
	// 设置outputChannel
	OutputChannel = outputChannel
	WebDicInit()
	//fmt.Println(WebDic["unKnown"])
	for _, c := range Clients {
		// 添加内核扫描
		//for _, u := range UnameDic[c.Uname.Version] {
		//	WaitGroup.Add(1)
		//	Pool.Invoke(&Task{
		//		Client: &c,
		//		POC:    poc,
		//	})
		//}

		// 添加docker扫描
		WaitGroup.Add(1)
		dockerPocFile, err := os.Open("./depot/docker/container-escape-check.sh")
		if err != nil {
			return err
		}
		dockerPocData, err := io.ReadAll(dockerPocFile)
		if err != nil {
			return err
		}

		dockerPoc := ExecPOC{
			Name: "docker-escape",
			data: map[string]string{},
		}
		encodeString := base64.StdEncoding.EncodeToString(dockerPocData)
		dockerPoc.data["exp.sh"] = encodeString
		Pool.Invoke(&Task{
			Client:  &c,
			Service: "docker",
			Version: "",
			POC:     dockerPoc,
		})

		// 添加web应用扫描
		for k, v := range c.Services {
			for _, s := range WebDic[fmt.Sprintf("%s%s", k, v.Version)] {
				WaitGroup.Add(1)
				//fmt.Println(s)
				if strings.HasPrefix(s, "xray") {
					yamlFile, err := os.Open("./depot/web/" + s)
					if err != nil {
						return err
					}
					byteValue, err := io.ReadAll(yamlFile)
					if err != nil {
						return err
					}

					yamlFile.Close()

					xray_poc, _ := xray_parse.ParsePocByte(byteValue)
					Pool.Invoke(&Task{
						Client:  &c,
						Service: k,
						Version: v.Version,
						POC:     RequestPOC{Name: s, PocInterface: xray_poc},
					})
				} else if strings.HasPrefix(s, "nuclei") {
					nucleiPoc, err := nuclei_parse.ParsePoc("./depot/web/" + s)
					if err != nil {
						return err
					}
					Pool.Invoke(&Task{
						Client:  &c,
						Service: k,
						Version: v.Version,
						POC:     RequestPOC{Name: s, PocInterface: nucleiPoc},
					})
				}
			}
		}
	}
	return nil
}

// Wait 等待协程池结束后发送结束信号
func Wait() {
	WaitGroup.Wait()
	done <- struct{}{}
}

func end() {
	for _, c := range Clients {
		c.ClientApiReq("exit", struct{}{})
	}
	close(done)
	close(OutputChannel)
	Pool.Release()
}

func check(taskInterface interface{}) {
	task := taskInterface.(*Task)
	defer WaitGroup.Done()
	<-Ticker.C
	client := task.Client

	switch task.POC.(type) {
	// 内核等需要执行elf的任务
	case ExecPOC:
		poc := task.POC.(ExecPOC)

		type fileUpload struct {
			Path string `json:"path"`
			Data string `json:"data"`
		}

		for k, v := range poc.data {
			f := fileUpload{
				Path: "/tmp/" + k,
				Data: v,
			}
			req, err := client.ClientApiReq("api/upload", f)
			if err != nil {
				return
			}
			fmt.Println(req)
			req, err = client.ClientExec([]string{"chmod", "+x", "/tmp/" + k})
			if err != nil {
				return
			}
			fmt.Println(req)
			req, err = client.ClientExec([]string{"/tmp/" + k})
			if err != nil {
				return
			}
			fmt.Println(req)
			//client.ClientExec()

			OutputChannel <- &Result{
				Client: client,
				PocRes: &PocResult{
					Success: false,
					Service: task.Service,
					Version: task.Version,
					PocName: poc.Name,
				},
			}
		}
	// web poc 任务
	case RequestPOC:
		poc := task.POC.(RequestPOC)
		oRequest, _ := http.NewRequest("GET", fmt.Sprintf("http://%s:%s", client.Host, client.Services[task.Service].Port), nil)
		fmt.Printf("checking %s use %s\n", client.Name, poc.Name)
		switch poc.PocInterface.(type) {
		// xray 的 poc
		case *xray_struct.Poc:
			xrayPoc := poc.PocInterface.(*xray_struct.Poc)
			isVul, _ := poc_check.ExecuteXrayPoc(oRequest, fmt.Sprintf("http://%s:%s", client.Host, client.Services[task.Service].Port), xrayPoc)
			OutputChannel <- &Result{
				Client: client,
				PocRes: &PocResult{
					Success: isVul,
					Service: task.Service,
					Version: task.Version,
					PocName: xrayPoc.Name,
				},
			}
		// nuclei 的 poc
		case *nuclei_structs.Poc:
			nucleiPoc := poc.PocInterface.(*nuclei_structs.Poc)
			results, isVul, _ := poc_check.ExecuteNucleiPoc(fmt.Sprintf("http://%s:%s", client.Host, client.Services[task.Service].Port), nucleiPoc)
			for _, r := range results {

				OutputChannel <- &Result{
					Client: client,
					PocRes: &PocResult{
						Success: isVul,
						Service: task.Service,
						Version: task.Version,
						PocName: r.TemplateID,
					},
				}
			}
		}

	}
}

// GetResult 循环接收结果，加入client结果集中，同时接收结束信号
func GetResult() {
	for {
		select {
		case res := <-OutputChannel:
			if res.PocRes.Success {
				//fmt.Printf("checking %s use %s\n", res.Client.Name, resTrue)
				*res.Client.Res = append(*res.Client.Res, table.Row{res.PocRes.Service, res.Client.Services[res.PocRes.Service].Port, res.PocRes.Version, res.PocRes.PocName, resTrue})
			} else {
				//fmt.Printf("checking %s use %s\n", res.Client.Name, resFalse)
				*res.Client.Res = append(*res.Client.Res, table.Row{res.PocRes.Service, res.Client.Services[res.PocRes.Service].Port, res.PocRes.Version, res.PocRes.PocName, resFalse})
			}
		case <-done:
			goto END
		}
	}
END:
	for _, c := range Clients {
		c.PrintRes()
	}

	end()
}
