package utils

import (
	"bytes"
	"fmt"
	"github.com/emirpasic/gods/queues/arrayqueue"
	"github.com/emirpasic/gods/trees"
	"log"
	"os/exec"
)

// NetTree 网络拓扑树
type NetTree struct {
	trees.Tree
	Root *Node // Root node
	//size int   // Total number of keys in the tree
	//Addr string
}

// Node 树节点
type Node struct {
	Parent   *Node
	Entries  []*Entry // Contained keys in node
	Children []*Node  // Children nodes
}

// Entry 键值对
type Entry struct {
	Key   interface{}
	Value interface{}
}

func getCommandOutput(command string, args ...string) string {
	//fmt.Print(args)
	cmd := exec.Command(command, args...)
	var out bytes.Buffer
	cmd.Stdout = &out
	err := cmd.Run()
	if err != nil {
		return fmt.Sprintf("Error running %s %s: %s", command, args, err)
	}
	return out.String()
}

func NewNetTree(addr string) *NetTree {
	entry := &Entry{Key: "addr", Value: addr}
	return &NetTree{
		Root: &Node{Parent: nil, Entries: []*Entry{entry}, Children: []*Node{}},
	}
}

// AddChildrenByAddr 广搜搜索节点，插入可到达子节点
func (t NetTree) AddChildrenByAddr(key string, addrs []string) {
	queue := arrayqueue.New()
	queue.Enqueue(t.Root)

	for !queue.Empty() {
		nodeInterface, _ := queue.Dequeue()
		node := nodeInterface.(*Node)
		if node.Entries[0].Value == key {
			for _, addr := range addrs {
				node.Children = append(node.Children, &Node{
					Parent:   node,
					Entries:  []*Entry{{Key: "addr", Value: addr}},
					Children: []*Node{},
				})
			}
			break
		} else {
			for _, c := range node.Children {
				queue.Enqueue(c)
			}
		}
	}

	//for _, addr := range addrs {
	//	entry := &Entry{Key: "addr", Value: addr}
	//
	//}
}

func (t NetTree) PrintValues() {
	queue := arrayqueue.New()
	queue.Enqueue(t.Root)

	for !queue.Empty() {
		nodeInterface, _ := queue.Dequeue()
		node := nodeInterface.(*Node)
		log.Printf("tree addr %p, children %v, value %v\n", nodeInterface, node.Children, node.Entries[0])
		for _, c := range node.Children {
			queue.Enqueue(c)
		}
	}
}
