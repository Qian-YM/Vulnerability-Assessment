package main

import (
	"errors"
	"io"
	"log"
	"os"
	"sync"
	"vulAssess/target"
	"vulAssess/utils"
)

type execRes struct {
	t        *target.SSHTarget
	category string
	res      string
}

// TODO: 每个靶机单独处理错误，而不是收到错误直接结束
func run(t target.SSHTarget, errChan chan error, resChan chan execRes) {
	err := target.GetArch(t)
	if err != nil {
		errChan <- err
		return
	}
	err = t.UploadClient()
	if err != nil {
		errChan <- err
		return
	}
	err = t.ActiveClient()
	if err != nil {
		errChan <- err
		return
	}
	err = t.TestClient()
	if err != nil {
		errChan <- err
		return
	}
	resChan <- execRes{
		t:        &t,
		category: "active",
		res:      "",
	}
}

func topoNet(t target.SSHTarget, ipList []string, errChan chan error, resChan chan execRes) {
	var ip struct {
		Ip []string `json:"ip"`
	}
	ip.Ip = ipList
	res, err := t.ApiRunCommand("ping_host", ip)
	if err != nil {
		errChan <- err
	}
	resChan <- execRes{
		t:        &t,
		category: "topo",
		res:      res,
	}
}

func Entry() {
	// TODO: ssh弱口令检查
	errRes := make(chan error)
	resChan := make(chan execRes)
	done := make(chan struct{})

	var wg sync.WaitGroup
	wg.Add(len(targets))

	netTree := utils.NewNetTree("127.0.0.1")
	var unReachable []string
	var reachable []string

	for _, t := range targets {
		err := target.DiscoveryHost(t.GetClientTarget())
		if err == nil {
			reachable = append(reachable, t.Addr.String())
			go run(t, errRes, resChan)
		} else {
			log.Println(err)
			unReachable = append(unReachable, t.Addr.String())
			wg.Done()
		}
	}

	netTree.AddChildrenByAddr("127.0.0.1", reachable)
	// 等待关闭信号
	go func() {
		wg.Wait()
		done <- struct{}{}
	}()

	// 循环等待
	for {
		select {
		case err := <-errRes:
			if err != nil {
				panic(err)
			}
		case res := <-resChan:
			switch res.category {
			case "active":
				go topoNet(*res.t, unReachable, errRes, resChan)
			case "topo":
				// TODO: 接收可ping通的ip,加入拓扑树中
				// 使用树记录网络拓扑，根节点为自身，儿子为可以ping通的ip
				// end

				// TODO: 解析res(json格式)插入网络拓扑树
				defer wg.Done()
				log.Println(res.res)

			default:
				panic(errors.New(res.category))
			}
		case <-done:
			goto End
		}
	}
End:
	netTree.PrintValues()
}

// TODO: 整理代码，统一错误处理
// TODO: 将配置写入config文件
func main() {

	//Entry()

	yamlFile, err := os.Open("./depot/poc/apache-httpd-cve-2021-40438-ssrf.yml")
	if err != nil {
		log.Fatal(err)
		return
	}
	defer yamlFile.Close()
	byteValue, err := io.ReadAll(yamlFile)
	if err != nil {
		log.Fatal(err)
		return
	}
	//var poc utils.
	poc, err := utils.GetPoc(byteValue)
	//res, err :=
	log.Println(poc.GetRule())
	res, err := poc.GetPoc()

	log.Println(res.(map[string]utils.RequestRule)["r0"].Expression)

	//go collect.GetServer(target.ClientTarget{
	//	Addr:      "http://125.220.147.45:12345",
	//	ProxyAddr: "http://127.0.0.1:8888",
	//})
	// TODO: 从靶机收集的信息基于payload
	// TODO: 执行从 yml 获取的 poc
}
