package temp

import (
	"bytes"
	"fmt"
	"github.com/emirpasic/gods/queues/arrayqueue"
	"github.com/emirpasic/gods/trees"
	"log"
	"os/exec"
)

// NetTree 网络拓扑树
type NetTree struct {
	trees.Tree
	Root *Node // Root node
	//size int   // Total number of keys in the tree
	//Addr string
}

// Node 树节点
type Node struct {
	Parent   *Node
	Entries  []*Entry // Contained keys in node
	Children []*Node  // Children nodes
}

// Entry 键值对
type Entry struct {
	Key   interface{}
	Value interface{}
}

func getCommandOutput(command string, args ...string) string {
	//fmt.Print(args)
	cmd := exec.Command(command, args...)
	var out bytes.Buffer
	cmd.Stdout = &out
	err := cmd.Run()
	if err != nil {
		return fmt.Sprintf("Error running %s %s: %s", command, args, err)
	}
	return out.String()
}

func NewNetTree(addr string) *NetTree {
	entry := &Entry{Key: "addr", Value: addr}
	return &NetTree{
		Root: &Node{Parent: nil, Entries: []*Entry{entry}, Children: []*Node{}},
	}
}

// AddChildrenByAddr 广搜搜索节点，插入可到达子节点
func (t NetTree) AddChildrenByAddr(key string, addrs []string) {
	queue := arrayqueue.New()
	queue.Enqueue(t.Root)

	for !queue.Empty() {
		nodeInterface, _ := queue.Dequeue()
		node := nodeInterface.(*Node)
		if node.Entries[0].Value == key {
			for _, addr := range addrs {
				node.Children = append(node.Children, &Node{
					Parent:   node,
					Entries:  []*Entry{{Key: "addr", Value: addr}},
					Children: []*Node{},
				})
			}
			break
		} else {
			for _, c := range node.Children {
				queue.Enqueue(c)
			}
		}
	}

	//for _, addr := range addrs {
	//	entry := &Entry{Key: "addr", Value: addr}
	//
	//}
}

func (t NetTree) PrintValues() {
	queue := arrayqueue.New()
	queue.Enqueue(t.Root)

	for !queue.Empty() {
		nodeInterface, _ := queue.Dequeue()
		node := nodeInterface.(*Node)
		log.Printf("tree addr %p, children %v, value %v\n", nodeInterface, node.Children, node.Entries[0])
		for _, c := range node.Children {
			queue.Enqueue(c)
		}
	}
}

//func run(t target.SSHTarget, errChan chan error, resChan chan execRes) {
//	err := target.GetArch(t)
//	if err != nil {
//		errChan <- err
//		return
//	}
//	err = t.UploadClient()
//	if err != nil {
//		errChan <- err
//		return
//	}
//	err = t.ActiveClient()
//	if err != nil {
//		errChan <- err
//		return
//	}
//	err = t.TestClient()
//	if err != nil {
//		errChan <- err
//		return
//	}
//	resChan <- execRes{
//		t:        &t,
//		category: "active",
//		res:      "",
//	}
//}
//
//func topoNet(t target.SSHTarget, ipList []string, errChan chan error, resChan chan execRes) {
//	var ip struct {
//		Ip []string `json:"ip"`
//	}
//	ip.Ip = ipList
//	res, err := t.ApiRunCommand("ping_host", ip)
//	if err != nil {
//		errChan <- err
//	}
//	resChan <- execRes{
//		t:        &t,
//		category: "topo",
//		res:      res,
//	}
//}

//func Entry() {
//	// TODO: ssh弱口令检查
//	errRes := make(chan error)
//	resChan := make(chan execRes)
//	done := make(chan struct{})
//
//	var wg sync.WaitGroup
//	wg.Add(len(targets))
//
//	netTree := utils.NewNetTree("127.0.0.1")
//	var unReachable []string
//	var reachable []string
//
//	for _, t := range targets {
//		err := target.DiscoveryHost(t.GetClientTarget())
//		if err == nil {
//			reachable = append(reachable, t.Addr.String())
//			go run(t, errRes, resChan)
//		} else {
//			log.Println(err)
//			unReachable = append(unReachable, t.Addr.String())
//			wg.Done()
//		}
//	}
//
//	netTree.AddChildrenByAddr("127.0.0.1", reachable)
//	// 等待关闭信号
//	go func() {
//		wg.Wait()
//		done <- struct{}{}
//	}()
//
//	// 循环等待
//	for {
//		select {
//		case err := <-errRes:
//			if err != nil {
//				panic(err)
//			}
//		case res := <-resChan:
//			switch res.category {
//			case "active":
//				go topoNet(*res.t, unReachable, errRes, resChan)
//			case "topo":
//				// TODO: 接收可ping通的ip,加入拓扑树中
//				// 使用树记录网络拓扑，根节点为自身，儿子为可以ping通的ip
//				// end
//
//				// TODO: 解析res(json格式)插入网络拓扑树
//				defer wg.Done()
//				log.Println(res.res)
//
//			default:
//				panic(errors.New(res.category))
//			}
//		case <-done:
//			goto End
//		}
//	}
//End:
//	netTree.PrintValues()
//}
