package tmp

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
	"time"
)

var (
	webpath      = "/"
	webhookURL   = "http://localhost:5000/upload"
	filename     string
	ipaddress    string
	reportHeader = "## Report Generated\n"
)

func initall() {
	// 获取本机IP地址
	ipaddress = getIPAddress()

	// 构建日志文件名
	filename = fmt.Sprintf("%s_%s_%s_%d_log.md", ipaddress, hostname(), whoami(), time.Now().Unix())
}

func printMsg(msg string) {
	fmt.Printf("%s\n", msg)
	saveToFile(msg + "\n")
}

func printCode(code string) {
	formattedCode := fmt.Sprintf("```shell\n%s\n```\n", code)
	fmt.Printf("%s", formattedCode)
	saveToFile(formattedCode)
}

func reverseShellCheck(path string) {
	output := getCommandOutput("bash", "-c", fmt.Sprintf("grep -lR 'sh -i' %s", path))
	if !strings.Contains(output, "exit") {
		printCode(output)
	} else {
		printMsg(fmt.Sprintf("No backdoor found in %s", path))
	}
}

func saveToFile(content string) {
	file, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		fmt.Printf("无法打开文件: %v\n", err)
		return
	}
	defer file.Close()

	if _, err := file.WriteString(content); err != nil {
		fmt.Printf("无法写入文件: %v\n", err)
	}
}

func getIPAddress() string {
	out, err := exec.Command("ip", "address").Output()
	if err != nil {
		fmt.Println("无法获取IP地址:", err)
		return ""
	}
	ip := parseIPAddress(string(out))
	return ip
}

func parseIPAddress(output string) string {
	lines := strings.Split(output, "\n")
	for _, line := range lines {
		if strings.Contains(line, "inet ") {
			ip := strings.Fields(line)[1]
			ip = strings.Split(ip, "/")[0]
			if !strings.Contains(line, "127.0.0.1") {
				return ip
			}
		}
	}
	return ""
}

func hostname() string {
	out, err := os.Hostname()
	if err != nil {
		fmt.Println("无法获取主机名:", err)
		return ""
	}
	return out
}

func whoami() string {
	out, err := exec.Command("whoami").Output()
	if err != nil {
		fmt.Println("无法获取当前用户:", err)
		return ""
	}
	return strings.TrimSpace(string(out))
}

func detectOS() string {
	osType := "None"
	if _, err := os.Stat("/etc/os-release"); err == nil {
		out, err := exec.Command("bash", "-c", "source /etc/os-release && echo $ID").Output()
		if err != nil {
			fmt.Println("无法识别操作系统:", err)
			return osType
		}
		osType = strings.TrimSpace(string(out))
	} else {
		if _, err := exec.LookPath("apt-get"); err == nil {
			osType = "Debian"
		} else if _, err := exec.LookPath("yum"); err == nil {
			osType = "CentOS"
		}
	}
	return osType
}

func installRequiredTools(osType string, tools []string) {
	var cmd *exec.Cmd
	osType = strings.ToLower(osType) // 转换为小写

	for _, tool := range tools {
		switch osType {
		case "debian", "ubuntu": // 包括 Debian 和 Ubuntu
			cmd = exec.Command("apt", "install", "-y", tool)
		case "centos":
			cmd = exec.Command("yum", "install", "-y", tool)
		default:
			continue
		}

		out, err := cmd.CombinedOutput()
		if err != nil {
			fmt.Printf("安装 %s 失败: %v\n", tool, err)
			continue
		}
		fmt.Printf("安装 %s 成功:\n%s\n", tool, string(out))
	}
}

func pre() {
	initall()
	printMsg(reportHeader)

	printMsg("## 环境检测")

	// 验证是否为root权限
	if os.Geteuid() != 0 {
		printMsg("请使用root权限运行！")
		os.Exit(1)
	} else {
		printMsg("当前为root权限！")
	}

	// 系统识别
	osType := detectOS()
	if osType == "None" {
		printMsg("不支持此操作系统")
		os.Exit(1)
	}
	printMsg(fmt.Sprintf("当前操作系统：%s", osType))

	// 安装必备工具
	requiredTools := []string{
		"net-tools",
		"telnet",
		"nc",
		"lrzsz",
		"wget",
		"strace",
		"traceroute",
		"htop",
		"tar",
		"lsof",
		"tcpdump",
	}

	installRequiredTools(osType, requiredTools)
}
