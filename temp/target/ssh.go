package target

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/pkg/sftp"
	"golang.org/x/crypto/ssh"
	"golang.org/x/net/proxy"
	"io"
	"log"
	"os"
	"path"
	"path/filepath"
)

// TODO: ssh target 继承 target，方法上升至target, 分离proxy

type SSHTarget struct {
	ClientTarget
	SSHPort uint16

	SSHConfig *ssh.ClientConfig
	Arch      string // architecture
}

func (t SSHTarget) GetSSHAddr() string {
	return fmt.Sprintf("%v:%d", t.Addr.String(), t.SSHPort)
}

func (t SSHTarget) GetClientTarget() ClientTarget {
	return t.ClientTarget
}

// ProxiedSSHClient 返回ssh连接
func ProxiedSSHClient(proxyAddress, sshServerAddress string, sshConfig *ssh.ClientConfig) (*ssh.Client, error) {
	if proxyAddress == "" {
		return ssh.Dial("tcp", sshServerAddress, sshConfig)
	} else {
		dialer, err := proxy.SOCKS5("tcp", proxyAddress, nil, proxy.Direct)
		if err != nil {
			return nil, err
		}

		conn, err := dialer.Dial("tcp", sshServerAddress)
		if err != nil {
			return nil, err
		}

		c, chans, reqs, err := ssh.NewClientConn(conn, sshServerAddress, sshConfig)
		if err != nil {
			return nil, err
		}

		return ssh.NewClient(c, chans, reqs), nil
	}
}

// UploadClient 将client提交至靶机
func (t SSHTarget) UploadClient() error {
	client, err := ProxiedSSHClient(t.GetSocksProxyAddr(), t.GetSSHAddr(), t.SSHConfig)
	if err != nil {
		return err
	}
	defer client.Close()

	sftpClient, err := sftp.NewClient(client)
	if err != nil {
		return err
	}
	defer sftpClient.Close()

	var file *os.File
	defer file.Close()
	// TODO: 添加多架构支持

	if t.Arch == "x86_64" || t.Arch == "amd64" {
		file, err = os.Open("./client/build/client-linux-amd64")
		if err != nil {
			return err
		}
	} else {
		//log.Println(t.Arch)
		return errors.New("unsupported architecture")
	}

	// TODO: 远端存在文件时会报错，后续改进为随机文件名
	var remoteFileName = path.Join("/tmp", filepath.Base("client"))
	dstFile, err := sftpClient.Create(remoteFileName)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	// 数据复制
	_, err = io.Copy(dstFile, file)
	if err != nil {
		return err
	}
	return nil
}

// ActiveClient 激活client
func (t SSHTarget) ActiveClient() error {
	// 建立SSH客户端连接
	client, err := ProxiedSSHClient(t.GetSocksProxyAddr(), t.GetSSHAddr(), t.SSHConfig)
	if err != nil {
		return err
	}
	defer client.Close()

	// 建立新会话
	session, err := client.NewSession()
	if err != nil {
		return err
	}
	defer session.Close()

	err = session.Run("chmod +x /tmp/client && nohup /tmp/client >/dev/null 2>&1 &")
	if err != nil {
		return err
	}

	err = session.Close()
	if err != nil && err != io.EOF {
		return err
	}
	return nil
}

func TestSSHConnect(targets []SSHTarget) error {
	for _, t := range targets {
		_, err := ProxiedSSHClient(t.GetSocksProxyAddr(), t.GetSSHAddr(), t.SSHConfig)
		if err != nil {
			//log.Fatalf("SSH dial error: %s", err.Error())
			return err
		}
	}
	return errors.New("empty target")
}

func GetArch(t SSHTarget) error {

	// 建立SSH客户端连接
	client, err := ProxiedSSHClient(t.GetSocksProxyAddr(), t.GetSSHAddr(), t.SSHConfig)
	if err != nil {
		//log.Fatalf("SSH dial error: %s", err.Error())
		return err
	}

	// 建立新会话
	session, err := client.NewSession()
	if err != nil {
		//log.Fatalf("new session error: %s", err.Error())
		return err
	}
	var b bytes.Buffer
	session.Stdout = &b
	// TODO: 不使用uname
	if err := session.Run("uname -m"); err != nil {
		return err
	}
	t.Arch = b.String()

	log.Printf("Arch: %v\n", b.String())

	err = session.Close()
	if err != nil && err != io.EOF {
		return err
	}
	err = client.Close()
	if err != nil {
		return err
	}
	return nil
}
