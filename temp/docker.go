package temp

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"
)

func docker_list() []string {
	//列举当前机器上所有docker容器的id
	//使用命令 docker ps -aq
	output, err := runCommand("bash", "-c", "docker ps -q")
	if err != nil {
		fmt.Println("Error running command:", err)
		return nil // 或者根据实际情况处理错误
	}
	// 将得到的所有id作为一个字符串数组返回
	lines := strings.Split(output, "\n")
	var res []string
	for _, line := range lines {
		if line != "" {
			// 假设每行只有一个id，直接添加到结果数组中
			res = append(res, line)
		}
	}
	return res
}

func check_one_docker(docker_id string) {

	output, err := runCommand("bash", "-c", "docker cp ./docker/container-escape-check.sh "+docker_id+":/")
	//runCommand("bash", "-c", "docker exec -i source /container-escape-check.sh")
	// 要执行的命令
	cmd := exec.Command("docker", "exec", "-i", docker_id, "/container-escape-check.sh")
	//cmd := exec.Command("docker", "exec", "-i", docker_id, "CheckCVE_2020_14386")
	// 创建用于捕获标准输出和标准错误的缓冲区
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	// 运行命令
	cmd.Run()
	if err != nil {
		fmt.Println("Error executing command:", err)
		fmt.Println("Standard Error:", stderr.String())
		return
	}

	// 打印标准输出和标准错误
	fmt.Println("Standard Output:", stdout.String())
	fmt.Println("Standard Error:", stderr.String())
	if err != nil {
		printCode("Error running hostnamectl: " + err.Error())
	} else {
		printCode(output)
	}

	runCommand("bash", "-c", "docker cp "+docker_id+":/res/res.json ./docker/")
}

type Info struct {
	PrivilegedMode      int `json:PrivilegedMode`
	DockerSocketMount   int `json:DockerSocketMount`
	ProcfsMount         int `json:ProcfsMount`
	RootDirectoryMount  int `json:RootDirectoryMount`
	DockerRemoteAPI     int `json:DockerRemoteAPI`
	cve_2016_5195       int `json:"cve_2016_5195"`
	cve_2020_14386      int `json:"cve_2020_14386"`
	cve_2022_0847       int `json:"cve_2022_0847"`
	cve_2017_1000112    int `json:"cve_2017_1000112"`
	cve_2021_22555      int `json:"cve_2021_22555"`
	HostVarLog          int `json:HostVarLog`
	CAP_DAC_READ_SEARCH int `json:CAP_DAC_READ_SEARCH`
	CAP_SYS_ADMIN       int `json:CAP_SYS_ADMIN`
	CAP_SYS_PTRACE      int `json:CAP_SYS_PTRACE`
	cve_2022_0492       int `json:"cve_2022_0492"`
}

func docker_parse() {
	// 打开JSON文件
	jsonFile, err := os.Open("./docker/res.json")
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}
	defer jsonFile.Close()

	// 读取JSON文件内容
	byteValue, err := ioutil.ReadAll(jsonFile)
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}
	// 解析JSON数据
	var info Info
	if err := json.Unmarshal(byteValue, &info); err != nil {
		fmt.Println("Error parsing JSON:", err)
		return
	}

	// 打印解析结果
	fmt.Println("\033[92m[+] PrivilegedMode:", info.PrivilegedMode, "\033[0m")
	fmt.Println("\033[92m[+] DockerSocketMount:", info.DockerSocketMount, "\033[0m")
	fmt.Println("\033[92m[+] ProcfsMount:", info.ProcfsMount, "\033[0m")
	fmt.Println("\033[92m[+] RootDirectoryMount:", info.RootDirectoryMount, "\033[0m")
	fmt.Println("\033[92m[+] DockerRemoteAPI:", info.DockerRemoteAPI, "\033[0m")
	fmt.Println("\033[92m[+] cve_2016_5195:", info.cve_2016_5195, "\033[0m")
	fmt.Println("\033[92m[+] cve_2020_14386:", info.cve_2020_14386, "\033[0m")
	fmt.Println("\033[92m[+] cve_2022_0847:", info.cve_2022_0847, "\033[0m")
	fmt.Println("\033[92m[+] cve_2017_1000112:", info.cve_2017_1000112, "\033[0m")
	fmt.Println("\033[92m[+] cve_2021_22555:", info.cve_2021_22555, "\033[0m")
	fmt.Println("\033[92m[+] HostVarLog:", info.HostVarLog, "\033[0m")
	fmt.Println("\033[92m[+] CAP_DAC_READ_SEARCH:", info.CAP_DAC_READ_SEARCH, "\033[0m")
	fmt.Println("\033[92m[+] CAP_SYS_ADMIN:", info.CAP_SYS_ADMIN, "\033[0m")
	fmt.Println("\033[92m[+] CAP_SYS_PTRACE:", info.CAP_SYS_PTRACE, "\033[0m")
	fmt.Println("\033[92m[+] cve_2022_0492:", info.cve_2022_0492, "\033[0m")
}

func dockerCheck() {
	docker_ids := docker_list()

	for i, docker_id := range docker_ids {
		fmt.Printf("%s\n", docker_id)
		i = i + 1

		check_one_docker(docker_id)
		docker_parse()
	}

}
