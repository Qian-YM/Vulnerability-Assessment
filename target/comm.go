package target

import (
	"crypto/tls"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"
)

// ApiRunCommand 将命令提交至client执行
func ApiRunCommand(t ClientTarget, command string) (string, error) {
	if t.ProxyAddr == "" {
		res, err := http.Post(fmt.Sprintf("%v/api/%v", t.Addr, command), "plain/text", nil)
		if err != nil {
			return "", err
		}
		body, err := io.ReadAll(res.Body)
		if err != nil {
			return "", err
		}
		res.Body.Close()
		return string(body), nil
	} else {
		proxy, _ := url.Parse(t.ProxyAddr)
		tr := &http.Transport{
			Proxy:           http.ProxyURL(proxy),
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		}
		client := &http.Client{
			Transport: tr,
			Timeout:   time.Second * 90, //超时时间
		}

		res, err := client.Post(fmt.Sprintf("%v/api/%v", t.Addr, command), "plain/text", nil)
		if err != nil {
			return "", err
		}

		body, _ := io.ReadAll(res.Body)
		res.Body.Close()
		return string(body), nil
	}
}

// ApiRunCommandALL 将命令提交至所有client执行
func ApiRunCommandALL(targets []ClientTarget, command string) (string, error) {
	for _, t := range targets {
		if t.ProxyAddr == "" {
			res, err := http.Post(fmt.Sprintf("%v/api/%v", t.Addr, command), "plain/text", nil)
			if err != nil {
				return "", err
			}
			body, err := io.ReadAll(res.Body)
			if err != nil {
				return "", err
			}
			res.Body.Close()
			return string(body), nil
		} else {
			proxy, _ := url.Parse(t.ProxyAddr)
			tr := &http.Transport{
				Proxy:           http.ProxyURL(proxy),
				TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
			}
			client := &http.Client{
				Transport: tr,
				Timeout:   time.Second * 5, //超时时间
			}

			res, err := client.Post(fmt.Sprintf("%v/api/%v", t.Addr, command), "plain/text", nil)
			if err != nil {
				return "", err
			}

			body, _ := io.ReadAll(res.Body)
			res.Body.Close()
			return string(body), nil
		}
	}
	return "", errors.New("empty targets")
}
