package target

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/pkg/sftp"
	"golang.org/x/crypto/ssh"
	"golang.org/x/net/proxy"
	"io"
	"log"
	"net"
	"os"
	"path"
	"path/filepath"
)

// TODO: ssh target 继承 target，方法上升至target, 分离proxy

type SSHTarget struct {
	Addr           net.IP
	SSHPort        uint16
	WebPort        uint16
	ProxyAddr      net.IP
	ProxySocksPort uint16
	ProxyHttpPort  uint16
	SSHConfig      *ssh.ClientConfig
	Arch           string // architecture
}

func (t SSHTarget) GetSSHAddr() string {
	return fmt.Sprintf("%v:%d", t.Addr.String(), t.SSHPort)
}

func (t SSHTarget) GetWebAddr() string {
	return fmt.Sprintf("http://%v:%d", t.Addr.String(), t.WebPort)
}

func (t SSHTarget) GetSocksProxyAddr() string {
	if t.ProxyAddr != nil {
		return fmt.Sprintf("%v:%d", t.ProxyAddr.String(), t.ProxySocksPort)
	} else {
		return ""
	}
}

func (t SSHTarget) GetHttpProxyAddr() string {
	if t.ProxyAddr != nil {
		return fmt.Sprintf("http://%v:%d", t.ProxyAddr.String(), t.ProxyHttpPort)
	} else {
		return ""
	}
}

// ProxiedSSHClient 返回ssh连接
func ProxiedSSHClient(proxyAddress, sshServerAddress string, sshConfig *ssh.ClientConfig) (*ssh.Client, error) {
	if proxyAddress == "" {
		return ssh.Dial("tcp", sshServerAddress, sshConfig)
	} else {
		dialer, err := proxy.SOCKS5("tcp", proxyAddress, nil, proxy.Direct)
		if err != nil {
			return nil, err
		}

		conn, err := dialer.Dial("tcp", sshServerAddress)
		if err != nil {
			return nil, err
		}

		c, chans, reqs, err := ssh.NewClientConn(conn, sshServerAddress, sshConfig)
		if err != nil {
			return nil, err
		}

		return ssh.NewClient(c, chans, reqs), nil
	}
}

// UploadClient 将client提交至靶机
func UploadClient(targets []SSHTarget) error {
	for i, t := range targets {
		client, err := ProxiedSSHClient(t.GetSocksProxyAddr(), t.GetSSHAddr(), t.SSHConfig)
		if err != nil {
			return err
		}

		sftpClient, err := sftp.NewClient(client)
		if err != nil {
			return err
		}

		var file *os.File
		// TODO: 添加多架构支持
		if t.Arch == "x86_64" {
			file, err = os.Open("./client/build/client-linux-amd64")
			if err != nil {
				return err
			}
		} else {
			return errors.New("unsupported architecture")
		}

		// TODO: 远端存在文件时会报错，后续改进为随机文件名
		var remoteFileName = path.Join("/tmp", filepath.Base("client"))

		dstFile, err := sftpClient.Create(remoteFileName)
		if err != nil {
			return err
		}

		// 数据复制
		_, err = io.Copy(dstFile, file)
		if err != nil {
			return err
		}
		log.Printf("Succeed to copy file to target %v\n", i)

		dstFile.Close()
		file.Close()
		sftpClient.Close()
		client.Close()
	}
	return errors.New("empty target")
}

// ActiveClient 激活client
func ActiveClient(targets []SSHTarget) error {
	for i, t := range targets {
		// 建立SSH客户端连接
		client, err := ProxiedSSHClient(t.GetSocksProxyAddr(), t.GetSSHAddr(), t.SSHConfig)
		if err != nil {
			return err
		}

		// 建立新会话
		session, err := client.NewSession()
		if err != nil {
			return err
		}

		if err := session.Run("chmod +x /tmp/client && nohup /tmp/client >/dev/null 2>&1 &"); err != nil {
			return err
		}

		log.Printf("target %v start success", i)

		err = session.Close()
		if err != nil && err != io.EOF {
			return err
		}
		err = client.Close()
		if err != nil {
			return err
		}
	}
	return errors.New("empty target")
}

func TestSSHConnect(targets []SSHTarget) error {
	for _, t := range targets {
		_, err := ProxiedSSHClient(t.GetSocksProxyAddr(), t.GetSSHAddr(), t.SSHConfig)
		if err != nil {
			//log.Fatalf("SSH dial error: %s", err.Error())
			return err
		}
	}
	return errors.New("empty target")
}

func GetArch(targets []SSHTarget) error {
	for i, t := range targets {
		// 建立SSH客户端连接
		client, err := ProxiedSSHClient(t.GetSocksProxyAddr(), t.GetSSHAddr(), t.SSHConfig)
		if err != nil {
			//log.Fatalf("SSH dial error: %s", err.Error())
			return err
		}

		// 建立新会话
		session, err := client.NewSession()
		if err != nil {
			//log.Fatalf("new session error: %s", err.Error())
			return err
		}
		var b bytes.Buffer
		session.Stdout = &b
		// TODO: 不使用uname
		if err := session.Run("uname -m"); err != nil {
			return err
		}
		t.Arch = b.String()

		log.Printf("target %v Arch: %v\n", i, b.String())

		err = session.Close()
		if err != nil && err != io.EOF {
			return err
		}
		err = client.Close()
		if err != nil {
			return err
		}
	}
	return errors.New("empty target")
}
