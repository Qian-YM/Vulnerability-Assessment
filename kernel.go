package main

import (
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"

	"github.com/hashicorp/go-version"
)

func extractKernelVersion(input string) (string, error) {
	// 定义正则表达式模式来匹配版本号
	re := regexp.MustCompile(`(\d+\.\d+\.\d+)`)

	// 查找匹配项
	match := re.FindStringSubmatch(input)
	if len(match) < 2 {
		return "", fmt.Errorf("no version found")
	}

	// 返回匹配的版本号
	return match[1], nil
}

func kernel_version() string {
	// 创建exec.Command来执行shell命令
	// output, err := runCommand("sh", "-c", "hostnamectl | grep -i kernel")
	output, err := runCommand("sh", "-c", "uname -r")
	if err != nil {
		printCode("Error running uname: " + err.Error())
	}
	version, err := extractKernelVersion(output)

	if err != nil {
		fmt.Println("Error:", err)
	} else {
		fmt.Println("Extracted version:", version)
	}

	return version
}

func getBoundaries(ver string) string {
	parts := strings.Split(ver, "Linux Kernel")
	left := strings.TrimSpace(parts[0])
	right := strings.TrimSpace(parts[1])

	return fmt.Sprintf("%s, %s", left, right)
}

func runPoc(pocPath string) error {
	cmd := exec.Command("sh", pocPath)
	err := cmd.Run()
	if err != nil {
		fmt.Printf("Error running poc %s: %s", pocPath, err)
		return err
	}
	fmt.Printf("Poc %s run successfully", pocPath)
	return nil
}

func checkCVE(ver string) {
	fmt.Println("check cve for given version")
	v, err := version.NewVersion(ver)
	if err != nil {
		fmt.Println("Error:", err)
	}
	dir := "./kernel/cve/"
	fmt.Printf("Entering dir: %s\n", dir)
	files, err := os.ReadDir(dir)
	if err != nil {
		fmt.Println("ReadDir Error:", err)
		return
	}

	for _, file := range files {
		if file.IsDir() {
			data, err := os.ReadFile(dir + "/" + file.Name() + "/version")
			if err != nil {
				fmt.Println("Error:", err)
			}

			boundary := getBoundaries(string(data))
			constraints, err := version.NewConstraint(boundary)
			if err != nil {
				fmt.Println("Error:", err)
			}
			if constraints.Check(v) {
				fmt.Printf("Version is in the range of %s", file.Name())
				runPoc(dir + "/" + file.Name() + "/exp.sh")
			}
		}
	}
}

//这里创建一个./kernel/cve的目录，里边存放着各种cve的相关信息包括版本、poc
//─ kernel
//└── cve
//    └── cve-xxxx-xxxx
//        ├── info.json
//        ├── poc
//        └── version

// 首先读version文件看看自己是否在这个范围内

// 如果在就跑poc

func rootkitCheck() {
	printMsg("## Rootkit检查")

	// 检查 lsmod 可疑模块
	printMsg("### lsmod 可疑模块")
	lsmodOutput, err := runCommand("lsmod")
	if err != nil {
		printCode("Error running lsmod: " + err.Error())
	} else {
		// 过滤掉已知的模块
		modules := filterModules(lsmodOutput)
		printCode(modules)
	}

	// 检查 Rootkit 内核模块
	printMsg("### Rootkit 内核模块")
	kallsymsOutput, err := runCommand("grep", "-E", "hide_tcp4_port|hidden_files|hide_tcp6_port|diamorphine|module_hide|module_hidden|is_invisible|hacked_getdents|hacked_kill|heroin|kernel_unlink|hide_module|find_sys_call_tbl|h4x_delete_module|h4x_getdents64|h4x_kill|h4x_tcp4_seq_show|new_getdents|old_getdents|should_hide_file_name|should_hide_task_name", "/proc/kallsyms")
	if err != nil {
		printCode("Error running grep on /proc/kallsyms: " + err.Error())
	} else if strings.TrimSpace(kallsymsOutput) != "" {
		printMsg("存在内核敏感函数！疑似Rootkit内核模块")
		printMsg(kallsymsOutput)
	} else {
		printMsg("未找到内核敏感函数")
	}

	// 检查可疑的 .ko 模块
	printMsg("### 可疑的.ko模块")
	findOutput, err := runCommand("find", "/", "!", "-path", "/var/lib/docker/overlay2/*", "!", "-path", "/proc/*", "!", "-path", "/usr/lib/modules/*", "!", "-path", "/lib/modules/*", "!", "-path", "/boot/*", "-regextype", "posix-extended", "-regex", ".*\\.ko")
	if err != nil {
		printCode("Error running find: " + err.Error())
	} else {
		suspiciousModules := filterModules(findOutput)
		printCode(suspiciousModules)
	}
}

func filterModules(output string) string {
	excludedModules := []string{
		"ablk_helper", "ac97_bus", "acpi_power_meter", "aesni_intel", "ahci",
		"ata_generic", "ata_piix", "auth_rpcgss", "binfmt_misc", "bluetooth",
		"bnep", "bnx2", "bridge", "cdrom", "cirrus", "coretemp", "crc_t10dif",
		"crc32_pclmul", "crc32c_intel", "crct10dif_common", "crct10dif_generic",
		"crct10dif_pclmul", "cryptd", "dca", "dcdbas", "dm_log", "dm_mirror",
		"dm_mod", "dm_region_hash", "drm", "drm_kms_helper", "drm_panel_orientation_quirks",
		"e1000", "ebtable_broute", "ebtable_filter", "ebtable_nat", "ebtables",
		"edac_core", "ext4", "fb_sys_fops", "floppy", "fuse", "gf128mul",
		"ghash_clmulni_intel", "glue_helper", "grace", "i2c_algo_bit", "i2c_core",
		"i2c_piix4", "i7core_edac", "intel_powerclamp", "ioatdma", "ip_set",
		"ip_tables", "ip6_tables", "ip6t_REJECT", "ip6t_rpfilter", "ip6table_filter",
		"ip6table_mangle", "ip6table_nat", "ip6table_raw", "ip6table_security",
		"ipmi_devintf", "ipmi_msghandler", "ipmi_si", "ipmi_ssif", "ipt_MASQUERADE",
		"ipt_REJECT", "iptable_filter", "iptable_mangle", "iptable_nat",
		"iptable_raw", "iptable_security", "iTCO_vendor_support", "iTCO_wdt",
		"jbd2", "joydev", "kvm", "kvm_intel", "libahci", "libata", "libcrc32c",
		"llc", "lockd", "lpc_ich", "lrw", "mbcache", "megaraid_sas", "mfd_core",
		"mgag200", "Module", "mptbase", "mptscsih", "mptspi", "nf_conntrack",
		"nf_conntrack_ipv4", "nf_conntrack_ipv6", "nf_defrag_ipv4", "nf_defrag_ipv6",
		"nf_nat", "nf_nat_ipv4", "nf_nat_ipv6", "nf_nat_masquerade_ipv4", "nfnetlink",
		"nfnetlink_log", "nfnetlink_queue", "nfs_acl", "nfsd", "parport",
		"parport_pc", "pata_acpi", "pcspkr", "ppdev", "rfkill", "sch_fq_codel",
		"scsi_transport_spi", "sd_mod", "serio_raw", "sg", "shpchp", "snd",
		"snd_ac97_codec", "snd_ens1371", "snd_page_alloc", "snd_pcm", "snd_rawmidi",
		"snd_seq", "snd_seq_device", "snd_seq_midi", "snd_seq_midi_event",
		"snd_timer", "soundcore", "sr_mod", "stp", "sunrpc", "syscopyarea",
		"sysfillrect", "sysimgblt", "tcp_lp", "ttm", "tun", "uvcvideo",
		"videobuf2_core", "videobuf2_memops", "videobuf2_vmalloc", "videodev",
		"virtio", "virtio_balloon", "virtio_console", "virtio_net", "virtio_pci",
		"virtio_ring", "virtio_scsi", "vmhgfs", "vmw_balloon", "vmw_vmci",
		"vmw_vsock_vmci_transport", "vmware_balloon", "vmwgfx", "vsock",
		"xfs", "xt_CHECKSUM", "xt_conntrack", "xt_state", "raid*", "tcpbbr",
		"btrfs", ".*diag", "psmouse", "ufs", "linear", "msdos", "cpuid", "veth",
		"xt_tcpudp", "xfrm_user", "xfrm_algo", "xt_addrtype", "br_netfilter",
		"input_leds", "sch_fq", "ib_iser", "rdma_cm", "iw_cm", "ib_cm", "ib_core",
		".*scsi.*", "tcp_bbr", "pcbc", "autofs4", "multipath", "hfs.*", "minix",
		"ntfs", "vfat", "jfs", "usbcore", "usb_common", "ehci_hcd", "uhci_hcd",
		"ecb", "crc32c_generic", "button", "hid", "usbhid", "evdev", "hid_generic",
		"overlay", "xt_nat", "qnx4", "sb_edac", "acpi_cpufreq", "ixgbe", "pf_ring",
		"tcp_htcp", "cfg80211", "x86_pkg_temp_thermal", "mei_me", "mei", "processor",
		"thermal_sys", "lp", "enclosure", "ses", "ehci_pci", "igb", "i2c_i801",
		"pps_core", "isofs", "nls_utf8", "xt_REDIRECT", "xt_multiport", "iosf_mbi",
		"qxl", "cdc_ether", "usbnet", "ip6table_raw", "skx_edac", "intel_rapl",
		"wmi", "acpi_pad", "ast", "i40e", "ptp", "nfit", "libnvdimm", "bpfilter",
		"failover", "toa", "tls", "nft_", "qemu_fw_cfg",
	}

	// Create a regex pattern to match the excluded modules
	pattern := strings.Join(excludedModules, "|")
	regex := regexp.MustCompile(pattern)

	// Filter out the excluded modules
	var filteredOutput []string
	for _, line := range strings.Split(output, "\n") {
		if !regex.MatchString(line) {
			filteredOutput = append(filteredOutput, line)
		}
	}

	return strings.Join(filteredOutput, "\n")
}

func checkLKM() {
	// 对可以的LKM进行内核fuzz
}

func checkKernel() {
	ver := kernel_version()
	// fmt.Printf("kernel version: %s", ver)
	checkCVE(ver)
}
